
# ------------------------------------------------------------------------- #
# --- Functions ----------------------------------------------------------- #
#
# Functions can be defined using the following syntax:

fun say_hello_to(name)
	print('Hello, ', name, '!\n\n');

# and now we can call it by doing

say_hello_to('Francesco');

# Functions can have an arbitrary amount of arguments. If the function is
# called with more arguments than it expected, the extra values are thrown
# away. If the function is called with less arguments than it expected,
# the argument set if filled up with none values.

fun test_func(a, b, c)
	{
		print('a = ', a, '\n');
		print('b = ', b, '\n');
		print('c = ', c, '\n\n');
	}

test_func();
# a = none
# b = none
# c = none

test_func(1, 2);
# a = 1
# b = 2
# c = none

test_func(1, 2, 3);
# a = 1
# b = 2
# c = 3

test_func(1, 2, 3, 4);
# a = 1
# b = 2
# c = 3

# Functions are actually variables like the ones that are be defined using
# the assignment operator. In fact, you can reassign them new values if you
# want.

test_func = 5;

# The following line, if executed, returns an error because the test_func
# identifier is now associated to 5, which is not a function. 

# test_func();

#
# ------------------------------------------------------------------------- #
# --- Returns ------------------------------------------------------------- #
#
# Functions can return values exactly like in other languages:

fun multiply(x, y)
	return x * y;

p = 4;
q = 7;
r = multiply(p, q);

print(p, ' * ', q, ' = ', r, '\n');

#
# ------------------------------------------------------------------------- #
# --- Scopes -------------------------------------------------------------- #
#
# Functions are always "pure", in the sense that the only values that the
# function body can access are the ones provided as arguments. Usually in
# other languages, functions can access the global scope and the parent
# scope (closures). There's no such mechanism in this language (at the 
# moment).
#
# The only exception is made for the "built in" variables, which are 
# provided by the runtime of the language, are accessible everywhere and
# can't be modified by the user. The print function is one of these 
# variables. One may override these variables but the effect only has
# effect within that context.

# Overwrite the print variable inside the global scope..
print = 5;

fun test()
	{
		# Now call print from inside the function.
		print('Not overwritten here!\n');

		# If the previous assignment were to overwrite the print function
		# globally, the previous statement would fail because the value 5
		# isn't a function.
	}

test();

# Now that i think about it, we lost the reference to the print function
# inside this scope. But we can take it back by returning it from a 
# function!

fun get_print_back()
	return print;

print = get_print_back();

print('Hei! Print is back!\n');

#
# ------------------------------------------------------------------------- #
# ------------------------------------------------------------------------- #

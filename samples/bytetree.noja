
fun newBytetree(leaf_size)
{
	if leaf_size == none:
		leaf_size = 64;

	return { root: none, size: 0, leaf_size: leaf_size };
}

fun makeBufferIntoTree(buffer)
{
	nleafs = 1.0 * count(data) / tree.leaf_size;
	assert(type(nleafs) == type(0.0));

	print('nleafs = ', nleafs, '\n');

	leafs = [];

	# Make a big buffer and then split it
	# into `nleafs` slices, then store the
	# slices into the `leafs` array.
	leafs_buffer = newBuffer(nleafs * tree.leaf_size);
	while count(leafs) < nleafs:
		leafs[count(leafs)] = 
			sliceBuffer(leafs_buffer, i * tree.leaf_size, tree.leaf_size);
	
	nodes = leafs;
	while count(nodes) > 1:
		{
			temp = [];

			npairs = count(nodes) / 2;

			while count(temp) < npairs:
				temp[count(temp)] = {
					left : nodes[count(temp) * 2],
					right: nodes[count(temp) * 2 + 1]
				};
			
			if npairs * 2 < count(nodes):
				# There's an extra node we
				# need to handle.
				temp[count(temp)-1] = {
					left: temp[count(temp)-1],
					right: nodes[count(nodes)-1]
				};
		
			nodes = temp;
		}

	assert(count(nodes) == 1);

	return nodes[0];
}

fun insertIntoBytetree(tree, data, index)
{
	if index == none:
		index = tree.size;

	subtree = makeBufferIntoTree(data);

	if tree.root == none:
		{
			tree.root = subtree;
			return;
		}

	# Now find where to store this
	# subtree.
	current = tree.root;


	rel_index = index;
	while type(current) == type({}):
		{
			if rel_index < current.left_size:
				current = current.left;
			else
				{
					rel_index = rel_index - current.left_size;
					current = current.right;
				}
		}

	
}